#!/bin/bash
# Hyprland Single Display Manager
# Automatically switches to primary monitor on device changes
# Can run as a service for automatic handling or be called manually

set -euo pipefail

# Color output for messages (only for terminal output)
RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
NC='\033[0m' # No Color

DAEMON_MODE="${DAEMON_MODE:-0}"

log_msg() {
    local msg="$1"
    local timestamp=$(date '+%Y-%m-%d %H:%M:%S')

    # Log to journalctl if running as daemon, otherwise to stdout
    if [ $DAEMON_MODE -eq 1 ]; then
        # Strip ANSI color codes for journalctl
        local clean_msg=$(echo -e "$msg" | sed 's/\x1b\[[0-9;]*m//g')
        echo "[${timestamp}] ${clean_msg}" | systemd-cat -t hyprland-single-display -p info
    fi

    # Also print to console with colors
    echo -e "${BLUE}[$timestamp]${NC} $msg"
}

switch_to_single_display() {
    local PRIMARY_MONITOR="${1:-}"

    if [ -z "$PRIMARY_MONITOR" ]; then
        # Check if DP-2 (external) is connected, otherwise use eDP-1 (built-in)
        local connected_monitors=$(hyprctl monitors -j | jq -r '.[].name' 2>/dev/null)

        if echo "$connected_monitors" | grep -q "DP-2"; then
            PRIMARY_MONITOR="DP-2"
        elif echo "$connected_monitors" | grep -q "eDP-1"; then
            PRIMARY_MONITOR="eDP-1"
        else
            # Fall back to first connected monitor
            PRIMARY_MONITOR=$(hyprctl monitors -j | jq -r '.[0].name' 2>/dev/null)
        fi

        if [ -z "$PRIMARY_MONITOR" ]; then
            log_msg "${RED}Error: Could not detect any monitor${NC}"
            return 1
        fi
    fi

    log_msg "${YELLOW}Switching to single display: $PRIMARY_MONITOR${NC}"

    # Get all connected monitors
    local MONITORS=$(hyprctl monitors -j | jq -r '.[].name' 2>/dev/null)

    if [ -z "$MONITORS" ]; then
        log_msg "${RED}Error: Could not list monitors${NC}"
        return 1
    fi

    # Disable all monitors except the primary one
    local changed=0
    for monitor in $MONITORS; do
        if [ "$monitor" != "$PRIMARY_MONITOR" ]; then
            log_msg "${YELLOW}Disabling: $monitor${NC}"
            hyprctl keyword monitor "$monitor,disable" 2>/dev/null || true
            changed=1
        fi
    done

    # Ensure primary monitor is enabled
    log_msg "${YELLOW}Enabling: $PRIMARY_MONITOR${NC}"
    hyprctl keyword monitor "$PRIMARY_MONITOR,highrr,auto,1" 2>/dev/null || true

    if [ $changed -eq 1 ]; then
        log_msg "${GREEN}Successfully switched to single display: $PRIMARY_MONITOR${NC}"
    else
        log_msg "${GREEN}Already in single display mode: $PRIMARY_MONITOR${NC}"
    fi
}

# Daemon mode: monitor for display changes via Hyprland IPC socket
daemon_mode() {
    log_msg "${BLUE}Starting Hyprland Single Display daemon${NC}"

    # Wait for Hyprland to be fully ready
    local max_retries=10
    local retry=0
    while [ $retry -lt $max_retries ]; do
        if [ -n "${HYPRLAND_INSTANCE_SIGNATURE:-}" ] && hyprctl monitors -j >/dev/null 2>&1; then
            break
        fi
        retry=$((retry + 1))
        log_msg "${YELLOW}Waiting for Hyprland to be ready... (attempt $retry/$max_retries)${NC}"
        sleep 1
    done

    if [ $retry -eq $max_retries ]; then
        log_msg "${RED}Error: Hyprland did not initialize within ${max_retries}s${NC}"
        exit 1
    fi

    # Initial setup
    switch_to_single_display

    # Get Hyprland socket path
    local socket_path="$XDG_RUNTIME_DIR/hypr/$HYPRLAND_INSTANCE_SIGNATURE/.socket2.sock"

    if [ ! -S "$socket_path" ]; then
        log_msg "${RED}Error: Hyprland IPC socket not found at $socket_path${NC}"
        log_msg "${YELLOW}Falling back to polling mode${NC}"
        fallback_polling_mode
        return
    fi

    log_msg "${GREEN}Connected to Hyprland IPC socket${NC}"

    # Monitor Hyprland events via IPC socket
    while true; do
        # Listen for monitor-related events
        socat - UNIX-CONNECT:"$socket_path" 2>/dev/null <<< "monitor" | while IFS= read -r event; do
            if [[ "$event" =~ ^(monitoradded|monitorremoved|monitorchanged) ]]; then
                log_msg "${YELLOW}Monitor event detected: $event${NC}"
                switch_to_single_display
            fi
        done

        # If socat connection is lost, wait and reconnect
        sleep 2
    done
}

# Fallback polling mode if socket is unavailable
fallback_polling_mode() {
    log_msg "${BLUE}Polling for monitor changes (fallback mode)${NC}"

    while true; do
        local current_monitors=$(hyprctl monitors -j | jq -r '[.[].name] | sort | join(",")')

        if [ "$current_monitors" != "${last_monitors:-}" ]; then
            log_msg "${YELLOW}Monitor configuration changed${NC}"
            switch_to_single_display
            last_monitors="$current_monitors"
        fi

        sleep 5
    done
}

# Main logic
case "${1:-manual}" in
    daemon)
        DAEMON_MODE=1
        daemon_mode
        ;;
    *)
        switch_to_single_display "${1:-}"
        ;;
esac
